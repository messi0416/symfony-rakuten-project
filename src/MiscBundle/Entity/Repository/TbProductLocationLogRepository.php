<?php

namespace MiscBundle\Entity\Repository;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Query\ResultSetMappingBuilder;
use MiscBundle\Entity\TbLocation;
use MiscBundle\Entity\TbProductLocationLog;
use MiscBundle\Entity\TbSetting;
use MiscBundle\Util\DbCommonUtil;
use \Doctrine\DBAL\DBALException;

/**
 * TbProductLocationLogRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TbProductLocationLogRepository extends BaseRepository
{
  /// テスト用
  public function getDatabaseName()
  {
    $logger = $this->getContainer()->get('misc.util.batch_logger');
    $logger->info('(in repository) ' . get_class($logger));

    $container = $this->getContainer();
    $logger->info('(in repository) ' . get_class($container));

    $db = $this->getConnection('main');
    $logger->info('(in repository) ' . get_class($db) . ' ' . $db->getDatabase());

    $db = $this->getConnection('log');
    $logger->info('(in repository) ' . get_class($db) . ' ' . $db->getDatabase());

    $repo = $this->getContainer()->get('doctrine')->getRepository('MiscBundle:TbLocation');
    $logger->info('(in repository) ' . get_class($repo));

    $em = $this->getEntityManager();
    return $em->getConnection()->getDatabase();
  }

  /**
   * 履歴翻訳
   * @param string $info
   * @param bool $regularOnly
   * @return array
   */
  public function convertInfoToArray($info, $regularOnly = true)
  {
    $result = [];
    $locationIds = [];

    if(!$info) {
      return $result;
    }

    $tmp = explode('/', $info);
    foreach($tmp as $line) {
      list($locationId, $stock, $position) = explode(':', $line);

      if (!isset($locationIds[$locationId])) {
        $locationIds[$locationId] = 1;
      }

      // 過去ロケーションスキップ
      if ($regularOnly && $position < 0) {
        continue;
      }

      $result[] = [
          'location_id' => $locationId
        , 'stock' => $stock
        , 'position' => $position
      ];
    }

    // ロケーションコード取得
    $locationIds = array_keys($locationIds);
    /** @var TbLocationRepository $repoLocation */
    $repoLocation = $this->getContainer()->get('doctrine')->getRepository('MiscBundle:TbLocation', 'main');

    /** @var TbLocation[] $locations */
    $locations = [];
    $tmp = $repoLocation->findByIds($locationIds);
    foreach($tmp as $location) {
      $locations[$location->getId()] = $location;
    }
    foreach($result as $i => $row) {
      $row['location_code'] = isset($locations[$row['location_id']]) ? $locations[$row['location_id']]->getLocationCode() : '(' . $row['location_id'] . ')';
      $result[$i] = $row;
    }

    return $result;
  }



  /**
   * 商品コードで商品ロケーション履歴取得
   * 直近から指定件数取得する
   * @param $syohinCode
   * @param int $limit
   * @return TbProductLocationLog[]
   */
  public function getBySyohinCode($syohinCode, $limit = 10)
  {
//    $db = $this->getEntityManager()->getConnection();
//
//    $qb = $this->createQueryBuilder('l');
//    $qb->andWhere($qb->expr()->eq('l.ne_syohin_syohin_code', $db->quote($syohinCode)));
//
//    $qb->addOrderBy('l.created', 'DESC');
//    $qb->setMaxResults($limit);
//
//    return $qb->getQuery()->getResult();

    $sql = <<<EOD
      SELECT
          l.*
        , c.comment
      FROM tb_product_location_log l
      LEFT JOIN tb_product_location_log_comment c ON l.action_key = c.action_key
                                                 AND l.created = c.created
      WHERE l.ne_syohin_syohin_code = :syohinCode
      ORDER BY l.id DESC
      LIMIT :limit
EOD;

    /** @var EntityManager $em */
    $em = $this->getEntityManager();

    $rsm =  new ResultSetMappingBuilder($em);
    $rsm->addRootEntityFromClassMetadata('MiscBundle:TbProductLocationLog', 'l');

    $query = $em->createNativeQuery($sql, $rsm);
    $query->setParameter(':syohinCode', $syohinCode, \PDO::PARAM_STR);
    $query->setParameter(':limit', $limit, \PDO::PARAM_INT);

    return $query->getResult();
    // return $query->iterate();
  }


  /**
   * ログ一覧CSVデータ取得
   *
   * @param array $conditions
   * @param string $mode all|location|product ※現在は location のみ対応
   * @return \PDOStatement
   * @throws \Doctrine\DBAL\DBALException
   */
  public function getLogCsvList($conditions, $mode = 'location')
  {
    $db = $this->getEntityManager()->getConnection();

    $params = [];
    $addConditionDateStart = '';
    $addConditionDateEnd = '';
    $addConditionAccount = '';
    $addConditionSyohinCode = '';

    // 日付
    if (!empty($conditions['date_start'])) {
      $addConditionDateStart = " AND l.created >= :dateStart ";
      $params[':dateStart'] = $conditions['date_start'];
    }
    if (!empty($conditions['date_end'])) {
      $addConditionDateEnd = " AND l.created <= :dateEnd ";
      $params[':dateEnd'] = $conditions['date_end'];
    }

    // 作業者（名前）
    if (!empty($conditions['account'])) {
      $addConditionAccount = " AND l.account = :account ";
      $params[':account'] = $conditions['account'];
    }

//    // 商品コード
//    if (!empty($conditions['ne_syohin_syohin_code'])) {
//      $addConditionSyohinCode = " AND l.ne_syohin_syohin_code = :neSyohinSyohinCode ";
//      $params[':neSyohinSyohinCode'] = $conditions['ne_syohin_syohin_code'];
//    }

    if ($mode == 'location') {

      $db->query("SET SESSION group_CONCAT_max_len = 10240");

      $sql = <<<EOD
      SELECT
          MIN(r.id)             AS record_id
        , MAX(l.created)        AS created
        , MAX(l.account)        AS account
        , MAX(l.operation)      AS operation
        , GROUP_CONCAT(DISTINCT r.`type`)  AS type
      --  , r.pre_warehouse_id
      --  , r.warehouse_id
        , r.pre_location_code
        , r.location_code

      --  , r.pre_stock
      --  , r.stock
      --  , r.pre_position
      --  , r.position

        , GROUP_CONCAT(DISTINCT r.ne_syohin_syohin_code) AS ne_syohin_syohin_code
        , MAX(c.`comment`)                               AS comment
        , r.action_key
      FROM tb_product_location_log l
      INNER JOIN tb_product_location_record_log r ON l.action_key = r.action_key
      LEFT JOIN tb_product_location_log_comment c ON l.action_key = c.action_key
                                                 AND l.created = c.created
      WHERE 1
        {$addConditionDateStart}
        {$addConditionDateEnd}
        {$addConditionAccount}
        {$addConditionSyohinCode}
      GROUP BY r.action_key
             , r.pre_location_code
             , r.location_code
      ORDER BY record_id ASC
EOD;
      $stmt = $db->prepare($sql);
      foreach($params as $k => $v) {
        $stmt->bindValue($k, $v, \PDO::PARAM_STR);
      }
      $stmt->execute();

    } else {
      throw new \RuntimeException('未対応のログ種別です。');
    }

    return $stmt;
  }

  /**
   * 商品ロケーション履歴 トリガ版 一覧取得
   * @param string $syohinCode
   * @param int $days
   * @return array
   * @throws \Doctrine\DBAL\DBALException
   */
  public function getLocationRecordLogsBySyohinCode($syohinCode, $days = 30)
  {
    $dbLog = $this->getConnection('log');

    // 主はトリガ保存レコード。ログsummaryが無くとも取得する。
    $sql = <<<EOD
      SELECT
          rl.*
        , pl.account
        , pl.operation
        , c.comment
      FROM tb_product_location_record_log       rl
      LEFT JOIN tb_product_location_log         pl ON pl.`type` = 'record' AND rl.action_key = pl.action_key
      LEFT JOIN tb_product_location_log_comment c  ON pl.action_key = c.action_key
      WHERE rl.log_date >= DATE_ADD(CURRENT_DATE, INTERVAL -1 * :days DAY)
        AND rl.ne_syohin_syohin_code = :syohinCode
      ORDER BY rl.log_date DESC
             , rl.id ASC
EOD;
    $stmt = $dbLog->prepare($sql);
    $stmt->bindValue(':days', $days, \PDO::PARAM_INT);
    $stmt->bindValue(':syohinCode', $syohinCode, \PDO::PARAM_STR);
    $stmt->execute();

    $recordListByDay = [];
    foreach($stmt as $row) {
      $date = $row['log_date'];
      if (!isset($recordListByDay[$date])) {
        $recordListByDay[$date] = [];
      }

      if (!isset($recordListByDay[$date][$row['action_key']])) {
        $recordListByDay[$date][$row['action_key']] = [];
      }

      $recordListByDay[$date][$row['action_key']][] = $row;
    }

    // トリガログの正規化
    foreach($recordListByDay as $date => $actions) {
      $result = [
          'snapshot' => []
        , 'actions' => []
      ];

      foreach($actions as $actionKey => $records) {
        $sample = $records[0];
        $result['actions'][$actionKey] = [
            'operation' => $sample['operation']
          , 'comment'   => $sample['comment']
          , 'account'   => $sample['account']
          , 'time'      => new \DateTime($sample['created'])
          , 'actions'   => $this->compactActionRecords($records)
        ];
      }

      $recordListByDay[$date] = $result;
    }

    // スナップショットを取得
    $snapshots = [];
    $dates = array_keys($recordListByDay);
    if ($dates) {
      $datesStr = implode(', ', array_map(function($date) use ($dbLog) { return $dbLog->quote($date); }, $dates));
      $sql = <<<EOD
        SELECT
            s.log_date
          , s.ne_syohin_syohin_code
          , s.location_code
          , s.warehouse_id
          , s.location_id
          , s.stock
          , s.position
        FROM tb_product_location_snapshot s
        WHERE s.log_date IN ( {$datesStr} )
          AND s.ne_syohin_syohin_code = :syohinCode
        ORDER BY s.log_date DESC
               , s.position
EOD;
      $stmt = $dbLog->prepare($sql);
      $stmt->bindValue(':syohinCode', $syohinCode);
      $stmt->execute();

      foreach($stmt as $location) {
        $date = $location['log_date'];
        if (!isset($snapshots[$date])) {
          $snapshots[$date] = [];
        }
        $snapshots[$date][] = $location;
      }

      foreach($snapshots as $date => $locations) {
        $recordListByDay[$date]['snapshot'] = $snapshots[$date];
      }
    }

    return $recordListByDay;
  }

  /**
   * 1操作分の履歴をまとめる
   * @param $records
   * @return array
   */
  public function compactActionRecords($records)
  {
    $result = [];

    // $records はトリガ挿入順なので、処理が行われた順であるはず。
    // その順に、上書き（・移動数は加算）していく。
    foreach($records as $record) {
      if ($record['type'] == 'd') {
        $warehouseId = $record['pre_warehouse_id'];
        $locationCode = $record['pre_location_code'];
        $position = $record['pre_position'];
      } else {
        $warehouseId = $record['warehouse_id'];
        $locationCode = $record['location_code'];
        $position = $record['position'];
      }

      $locationKey = sprintf('%s_%s', $warehouseId, $locationCode);
      $move = $record['stock'] - $record['pre_stock'];

      if (!isset($result[$locationKey])) {
        // 最初に現れるの処理が挿入であれば、存在しなかったロケーションのはず。
        if ($record['type'] == 'i') {
          $originalPos = -9999;
        } else {
          $originalPos = $record['pre_position'];
        }
        $result[$locationKey] = [
            'stock'    => 0
          , 'move'     => 0
          , 'position' => 0
          , 'warehouse_id' => $warehouseId
          , 'location_code' => $locationCode
          , 'original_position' => $originalPos
          , 'pre_warehouse_id' => $record['pre_warehouse_id']
          , 'pre_location_code' => $record['pre_location_code']
        ];
      }

      $result[$locationKey]['stock'] = $record['stock'];
      $result[$locationKey]['move'] += $move;
      $result[$locationKey]['position'] = $position;
      // ロケーションコードもどんどん上書き
      if ($record['pre_warehouse_id']) {
        $result[$locationKey]['pre_warehouse_id'] = $record['pre_warehouse_id'];
      }
      if (strlen($record['pre_location_code'])) {
        $result[$locationKey]['pre_location_code'] = $record['pre_location_code'];
      }

    }

    // もしなにも変更されていなければ行を削除 （削除＆挿入の名残レコードなど）
    foreach($result as $locationKey => $compare) {
      if (
           $compare['position'] == $compare['original_position']
        && $compare['move'] == 0
        && (
                ! strlen($compare['pre_warehouse_id'])
             || $compare['warehouse_id'] == $compare['pre_warehouse_id']
           )
        && (
                ! strlen($compare['pre_location_code'])
             || $compare['location_code'] == $compare['pre_location_code']
           )
      ) {
        unset($result[$locationKey]);
      }
    }

    return $result;
  }

  /**
   * 箱詰めスコア情報の取得
   * @param string $targetDate
   * @return array $list
   * @throws \Doctrine\DBAL\DBALException
   */
  public function fetchBoxedRefillScoreList($targetDate)
  {
    $list = [];
    $usernameList = $this->fetchNameListWhichIsEligible4BoxedRefillScore($targetDate);
    foreach ($usernameList as $username) {
      $userLogs = $this->fetchStatisticsOnUsersBoxedRefillScore($username, $targetDate);
      if (!empty($userLogs)) {
        $list[] = $userLogs;
      }
    }
    return $list;
  }

  /**
   * 箱詰めスコアの対象となるユーザ名の取得
   * @param string $targetDate
   * @return array
   * @throws \Doctrine\DBAL\DBALException
   */
  public function fetchNameListWhichIsEligible4BoxedRefillScore($targetDate)
  {
    $sql = <<<EOD
      SELECT
        log.account AS username
      FROM tb_product_location_record_log record 
      INNER JOIN tb_product_location_log log 
        ON  record.action_key = log.action_key
      WHERE record.type IN('d', 'u') 
        AND log.operation = '箱振り' 
        AND record.pre_location_code LIKE '%new%' 
        AND record.log_date >= :date
      GROUP BY log.account
      ORDER BY Max(log.created) DESC
EOD;
    $dbLog = $this->getEntityManager()->getConnection();
    $stmt = $dbLog->prepare($sql);
    $stmt->bindValue(':date', $targetDate, \PDO::PARAM_STR);
    $stmt->execute();

    $firstColumn = 0;
    return $stmt->fetchAll(\PDO::FETCH_COLUMN, $firstColumn);
  }

  /**
   * 個人の箱詰めスコア情報の取得
   * @param string $username
   * @param string $targetDate
   * @return array
   * @throws \Doctrine\DBAL\DBALException
   */
  public function fetchStatisticsOnUsersBoxedRefillScore($username, $targetDate)
  {
    /** @var TbSettingRepository $settingRepo */
    $settingRepo = $this->getContainer()->get('doctrine')->getRepository('MiscBundle:TbSetting');

    $firstLatestRecordCount  = (int)$settingRepo->find(TbSetting::KEY_BOXED_REFILL_RECORD_LIMIT_1)->getSettingVal();
    $secondLatestRecordCount = (int)$settingRepo->find(TbSetting::KEY_BOXED_REFILL_RECORD_LIMIT_2)->getSettingVal();
    $thirdLatestRecordCount  = (int)$settingRepo->find(TbSetting::KEY_BOXED_REFILL_RECORD_LIMIT_3)->getSettingVal();

    $sql = <<<EOD
      SELECT 
        record.created AS created
      FROM tb_product_location_record_log record
      INNER JOIN tb_product_location_log log 
        ON record.action_key = log.action_key
      WHERE record.type IN('d', 'u') 
        AND log.operation = '箱振り' 
        AND log.account = :username
        AND record.pre_location_code LIKE '%new%' 
        AND record.log_date >= :date
      ORDER BY log.created DESC
      LIMIT :limit
EOD;
    $dbLog = $this->getEntityManager()->getConnection();
    $stmt = $dbLog->prepare($sql);
    $stmt->bindValue(':username', $username, \PDO::PARAM_STR);
    $stmt->bindValue(':date', $targetDate, \PDO::PARAM_STR);
    $stmt->bindValue(':limit', $thirdLatestRecordCount, \PDO::PARAM_INT);
    $stmt->execute();

    if ($stmt->rowCount() < $firstLatestRecordCount) {
      return array();
    }

    $limitTimeBetweenOperations = 60 * 10; // 作業と作業の間が10分以上空いていたなら別作業を行っていたと判断し、計算の対象外にする

    $userStatistics = [
      'username' => $username,
      'firstColumnAverageTime'  => 0,
      'secondColumnAverageTime' => 0,
      'thirdColumnAverageTime'  => 0
    ];

    $totalTime        = 0;
    $validLogCount    = 0;
    $locationLogCount = 1;
    $previousCreatedSec = strtotime($stmt->fetch(\PDO::FETCH_ASSOC)['created']);
    while ($userLog = $stmt->fetch(\PDO::FETCH_ASSOC)) {
      ++$locationLogCount;

      $originSec = $previousCreatedSec;
      $targetSec = strtotime($userLog['created']);
      $diffTime  = $originSec - $targetSec;
      if ($diffTime < $limitTimeBetweenOperations) {
        ++$validLogCount;
      } else {
        $diffTime = 0;
      }

      $previousCreatedSec = $targetSec;
      $totalTime += $diffTime;

      if ($locationLogCount == $firstLatestRecordCount) {
        $userStatistics['firstColumnAverageTime']  = $totalTime / $validLogCount;
      } else if ($locationLogCount == $secondLatestRecordCount) {
        $userStatistics['secondColumnAverageTime'] = $totalTime / $validLogCount;
      } else if ($locationLogCount == $thirdLatestRecordCount) {
        $userStatistics['thirdColumnAverageTime']  = $totalTime / $validLogCount;
      }
    }

    return $userStatistics;
  }

  /**
   * 全体の平均時間を取得　
   * @deprecated 将来箱詰めスコアの改修があるときはサービスクラスに移動する
   * @param array $userStatisticsList
   * @return int
   */
  public function solveOverallAverageTime($userStatisticsList)
  {
    $validLogCount = count($userStatisticsList);
    $totalAverageTime = 0;
    // 全体平均を取得
    foreach ($userStatisticsList as $userStatistics) {
      if ($userStatistics['thirdColumnAverageTime'] == 0) {
        --$validLogCount;
        continue;
      }
      $totalAverageTime += $userStatistics['thirdColumnAverageTime'];
    }

    $averageTime = 0;
    if ($validLogCount > 0) {
      $averageTime = $totalAverageTime / $validLogCount;
    }
    return $averageTime;
  }

  /**
   * 最速時間を取得
   * @deprecated 将来箱詰めスコアの改修があるときはサービスクラスに移動する
   * @param array $userStatisticsList
   * @return int
   */
  public function getFastestTime($userStatisticsList)
  {
    // ありうる最遅値の秒数
    $minTime = 60 * 10;
    // 最速スコアを取得
    foreach ($userStatisticsList as $userStatistics) {
      if ($userStatistics['thirdColumnAverageTime'] == 0) {
        continue;
      }
      $minTime = min($minTime, $userStatistics['thirdColumnAverageTime']);
    }
    return $minTime;
  }

  /**
   * ピッキングスコアの対象となるユーザ名の取得
   * @param string $targetDate
   * @return array
   * @throws DBALException
   */
  public function fetchPickingScoreTargetUserList($targetDate)
  {
    $sql = <<<EOD
      SELECT
        log.account AS username
      FROM tb_product_location_log log
      WHERE log.operation IN ('ピッキング', '倉庫在庫ピッキング') AND 
        log.created >= :date
      GROUP BY log.account
      ORDER BY Max(log.created) DESC
EOD;
    $dbLog = $this->getConnection('log');
    $stmt = $dbLog->prepare($sql);
    $stmt->bindValue(':date', $targetDate, \PDO::PARAM_STR);
    $stmt->execute();

    $firstColumn = 0;
    return $stmt->fetchAll(\PDO::FETCH_COLUMN, $firstColumn);
  }

  /**
   * 個人のピッキングログを取得
   * @param string $username
   * @param string $targetDate
   * @return array
   * @throws DBALException
   */
  public function fetchPickingLog($username, $targetDate)
  {
    $dbLog = $this->getConnection('log');
    $sql = <<<EOD
      SELECT
        log.created AS created,
        record.action_key,
        record.location_code AS location_code
      FROM tb_product_location_log log
      LEFT JOIN tb_product_location_record_log record ON log.action_key = record.action_key
      WHERE log.operation IN ('ピッキング', '倉庫在庫ピッキング') 
        AND log.created >= :date 
        AND log.account = :username 
        AND record.stock <> record.pre_stock /* ポジション(ピッキング優先順位)更新処理Logを弾くために利用 -> ピッキング処理であれば在庫が変化している */
      ORDER BY log.created DESC
EOD;
    $stmt = $dbLog->prepare($sql);
    $stmt->bindValue(':username', $username, \PDO::PARAM_STR);
    $stmt->bindValue(':date', $targetDate, \PDO::PARAM_STR);
    $stmt->execute();
    return $stmt->fetchAll();
  }
}
