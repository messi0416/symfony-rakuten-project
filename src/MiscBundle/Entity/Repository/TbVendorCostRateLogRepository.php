<?php

namespace MiscBundle\Entity\Repository;

use MiscBundle\Util\DbCommonUtil;

/**
 * TbVendorCostRateLogRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TbVendorCostRateLogRepository extends BaseRepository
{

  /**
   * 指定期間について、仕入先別にデータを集計する
   *
   * * 売上額 合計
   * * 伝票粗利額 合計 （送料・消費税等含む）
   * * 平均原価率
   *
   * （仕様）複数仕入先の伝票が重複して計上されるのは許容し、伝票単位の粗利を商品に紐づく仕入先で集計する。
   *        （現行の tb_sales_detail_voucher_sire_order_ym の集計仕様と同様）
   * @param \DateTime $dateStart
   * @param \DateTime $dateEnd
   *
   * @return array
   */
  public function calculateCostRateHistoryList(\DateTime $dateStart, \DateTime $dateEnd, $mode = null)
  {
    $logDbName = $this->getConnection('log')->getDataBase();

    /** @var DbCommonUtil $commonUtil */
    $commonUtil = $this->getContainer()->get('misc.util.db_common');
    // SHOPLIST設定・フリー設定
    $shoppingMallShoplist = $commonUtil->getShoppingMall(DbCommonUtil::MALL_ID_SHOPLIST);
    $shoppingMallFree = $commonUtil->getShoppingMall(DbCommonUtil::MALL_ID_FREE_ORDER);
    if (!$shoppingMallShoplist || !$shoppingMallFree) {
      throw new \RuntimeException('モール設定が取得できませんでした。');
    }


    /** @var \Doctrine\DBAL\Connection $db */
    $db = $this->getConnection('main');

    $sql = <<<EOD
       SELECT
             sire.sire_code
           , sire.sire_name
           , SALES.粗利額
           , SALES.伝票金額
           , SALES.voucher_num
           , COALESCE(RATE_LOG.cost_rate_average, sire.cost_rate) AS cost_rate_average
           , sire.cost_rate
           , sire.表示順
           , sire.available_itemcnt AS item_count  /* 販売中商品数 */
           , sire.stock_amount /* 在庫金額 */
       FROM
           tb_vendormasterdata as sire
           LEFT JOIN (
               SELECT
                   sire_code
                 , ROUND(AVG(cost_rate)) as cost_rate_average
               FROM `{$logDbName}`.tb_vendor_cost_rate_log AS rate_log
               WHERE
                 log_date BETWEEN :dateStart AND :dateEnd
               GROUP BY sire_code
           ) AS RATE_LOG ON (sire.sire_code = RATE_LOG.sire_code)
           LEFT JOIN (
              SELECT
                     p.sire_code
                   , p.voucher_num
                   , p.粗利額
                   , p.伝票金額
              FROM (
                SELECT
                       p.sire_code
                     , COUNT(DISTINCT p.伝票番号) AS voucher_num
                     , SUM(粗利額) AS 粗利額
                     , SUM(伝票金額) AS 伝票金額
                FROM (
                   SELECT
                       m.sire_code
                     , p.伝票番号
                     , SUM(p.明細粗利額_伝票費用除外) AS 粗利額
                     , MAX(p.ポイント数を含む総合計) AS 伝票金額
                   FROM tb_sales_detail_profit AS p
                   INNER JOIN tb_mainproducts AS m ON p.代表商品コード = m.daihyo_syohin_code
                   INNER JOIN tb_mainproducts_cal cal ON p.代表商品コード = cal.daihyo_syohin_code
                   INNER JOIN tb_vendormasterdata as sire on m.sire_code = sire.sire_code
                   WHERE
                           p.受注年月日 BETWEEN :dateStart AND :dateEnd
                       AND p.代表商品コード <> ''
                       AND p.キャンセル区分 = '0'
                       AND p.明細行キャンセル = '0'
                       AND sire.取引状態 = 0
EOD;
    // 原価率設定の集計での除外条件
    if ($mode == 'costRate') {
      $sql .= <<<EOD
                       AND cal.cost_rate = 0 /* *今現在* 商品別原価率が設定されている商品の明細は除外 */
                       AND m.価格非連動チェック = 0 /* 価格非連動（値下げ含む）は除外 */
                       AND cal.mall_price_flg = 0 /* 価格非連動モールを持つ商品は除外 */
                       AND p.店舗コード <> :shoplistMallNeId /* SHOPLISTは固定価格のため除外 */
                       AND p.店舗コード <> :freeOrderMallNeId /* フリーオーダーも価格体系が別のため除外 */
EOD;
    }
    $sql .= <<<EOD
                   GROUP BY p.伝票番号, m.sire_code
                ) AS p
                GROUP BY p.sire_code
              ) AS p
           ) AS SALES ON sire.sire_code = SALES.sire_code
       WHERE sire.取引状態 = 0
       ORDER BY sire.表示順
EOD;

    $stmt = $db->prepare($sql);
    $stmt->bindValue(':dateStart', $dateStart->format('Y-m-d'));
    $stmt->bindValue(':dateEnd', $dateEnd->format('Y-m-d'));
    if ($mode == 'costRate') {
      $stmt->bindValue(':shoplistMallNeId', $shoppingMallShoplist->getNeMallId(), \PDO::PARAM_INT);
      $stmt->bindValue(':freeOrderMallNeId', $shoppingMallFree->getNeMallId(), \PDO::PARAM_INT);
    }
    $stmt->execute();

    $result = [];
    while($row = $stmt->fetch()) {
      $result[$row['sire_code']] = $row;
    }

    return $result;
  }

  /**
   * 仕入先別 期間内 原価率変動幅累積 取得
   * @param \DateTime $dateStart
   * @param \DateTime $dateEnd
   * @return array
   * @throws \Doctrine\DBAL\DBALException
   */
  public function getCostRateChangeSum($dateStart, $dateEnd)
  {
    $logDbName = $this->getConnection('log')->getDataBase();

    /** @var \Doctrine\DBAL\Connection $db */
    $db = $this->getConnection('main');

    $sql = <<<EOD
      SELECT
          sire_code
        , SUM(ABS(TT.cost_rate - TT.cost_rate_average)) AS change_sum
      FROM (
          SELECT
              L.sire_code
            , L.cost_rate
            , T.cost_rate_average
          FROM {$logDbName}.tb_vendor_cost_rate_log L
          INNER JOIN (
            SELECT
                L.sire_code
              , AVG(L.cost_rate) cost_rate_average
            FROM {$logDbName}.tb_vendor_cost_rate_log AS L
            INNER JOIN tb_vendormasterdata AS sire ON L.sire_code = sire.sire_code
            WHERE sire.取引状態 = 0
              AND log_date BETWEEN :dateStart AND :dateEnd
            GROUP BY L.sire_code
          ) T  ON L.sire_code = T.sire_code
          WHERE L.log_date BETWEEN :dateStart AND :dateEnd
      ) TT
      GROUP BY sire_code
EOD;

    $stmt = $db->prepare($sql);
    $stmt->bindValue(':dateStart', $dateStart->format('Y-m-d'), \PDO::PARAM_STR);
    $stmt->bindValue(':dateEnd', $dateEnd->format('Y-m-d'), \PDO::PARAM_STR);
    $stmt->execute();

    $result = [];
    foreach($stmt->fetchAll(\PDO::FETCH_ASSOC) as $row) {
      $result[$row['sire_code']] = $row['change_sum'];
    }

    return $result;
  }
}
