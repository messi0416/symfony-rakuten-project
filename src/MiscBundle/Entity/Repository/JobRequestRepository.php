<?php
namespace MiscBundle\Entity\Repository;
use MiscBundle\Entity\JobRequest;
use MiscBundle\Util\BatchLogger;

/**
 * JobRequestRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class JobRequestRepository extends BaseRepository
{
  const STATUE_NEW = 'NEW';
  const STATUE_QUEUED = 'QUEUED';
  const STATUE_STARTED = 'STARTED';
  const STATUE_FINISHED = 'FINISHED';
  const STATUE_ERROR = 'ERROR';

  const SINGLETON_WAIT_LIMIT_DEFAULT = 3600;

  /**
   * JobRequest 作成
   * @param string $key
   * @param string $process 処理コード (MainJob 定数)
   * @param \DateTimeInterface $expired
   * @param string $operator
   * @param array $options
   * @param bool $singleton 単一処理指定（同名処理を許可しない）
   * @param int $singletonTimeLimit
   * @return JobRequest
   */
  public function createJobRequest($key, $process, \DateTimeInterface $expired = null, $operator = '', $options = [], $singleton = false, $singletonTimeLimit = null)
  {
    /** @var BatchLogger $logger */
    $logger = $this->getContainer()->get('misc.util.batch_logger');

    $em = $this->getEntityManager();

    if ($singleton) {

      $singletonTimeLimit = intval($singletonTimeLimit);
      if (!$singletonTimeLimit) {
        $singletonTimeLimit = self::SINGLETON_WAIT_LIMIT_DEFAULT;
      }
      $timeLimitDateTime = (new \DateTimeImmutable())->modify(sprintf('- %d sec', $singletonTimeLimit));

      $list = $this->findByConditions([
        'process' => $process
      ]);

      if ($list) {
        $duplicated = null;

        foreach ($list as $jobRequest) {
          // NEWで有効期限切れはOK
          // NEWで長期間残ってブロックされるイレギュラーがあり得るため、expired_at を短くする運用を行う前提とする。
          if ($jobRequest->isExpired() && $jobRequest->getStatus() == self::STATUE_NEW) {
            continue;
          }

          // 指定時間以前の作成リクエストなら無視。（それだけ長時間残っている処理はないとして、ゴミとして扱う。）
          if ($jobRequest->getCreated() < $timeLimitDateTime) {
            continue;
          }

          if (in_array($jobRequest->getStatus(), [
              self::STATUE_QUEUED
            , self::STATUE_STARTED
          ])) {
            $duplicated = $jobRequest;
            break;
          }
        }

        if ($duplicated) {
          throw new JobRequestException(sprintf(
             'すでにキューへ追加済みの処理があります。[%s][%s][%s] 現在はこの処理の予約はできません。'
            , $duplicated->getStatus()
            , $duplicated->getCreated()->format('Y-m-d H:i:s')
            , $duplicated->getOperator()
          ));
        }
      }
    }

    if (!$expired) {
      $expired = new \DateTime();
      $expired->modify('+ 5 minutes'); // 初期値
    }

    $jobRequest = new JobRequest();

    $jobRequest->setJobKey($key);
    $jobRequest->setProcess($process);
    $jobRequest->setExpiredAt($expired);
    $jobRequest->setOptions(json_encode($options));
    $jobRequest->setOperator($operator);

    $em->persist($jobRequest);
    $em->flush();

    return $jobRequest;
  }

  /**
   * 条件指定で一覧取得
   * @param array $conditions
   * @return JobRequest[]
   */
  public function findByConditions($conditions = [])
  {
    $qb = $this->createQueryBuilder('r');

    if (!empty($conditions['process'])) {
      $qb->andWhere('r.process = :process')->setParameter(':process', $conditions['process']);
    }
    $qb->addOrderBy('r.created', 'ASC');

    return $qb->getQuery()->getResult();
  }

}

class JobRequestException extends \RuntimeException {};
