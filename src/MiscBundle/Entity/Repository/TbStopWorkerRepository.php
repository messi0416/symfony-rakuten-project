<?php

namespace MiscBundle\Entity\Repository;

use Doctrine\ORM\EntityRepository;
use MiscBundle\Entity\TbStopWorker;
use MiscBundle\Util\BatchLogger;
use Symfony\Component\Form\Exception\RuntimeException;
use Symfony\Component\HttpFoundation\JsonResponse;

/**
 * TbStopWorkerRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TbStopWorkerRepository extends BaseRepository
{
  /**
   * 時間前に起動していたり、同じワーカーで複数行で停止状態であれば古いほうを無効にする
   * @param array $isProcessingWorker
   * @param $queueNames
   * @throws \Doctrine\DBAL\DBALException
   */
  public function disableUnnecessaryStopFlg($isProcessingWorker,$queueNames){
    $logger = $this->getLogger();

    // 一つでも起動しているワーカーが存在するか
    if(count($isProcessingWorker) > 0){
      // 起動しているワーカーのレコードは無効に停止、していればそれぞれのワーカーの最終行以外を無効化
      $workerStrNames = [];
      for ($i = 0; $i < count($isProcessingWorker); $i++) {
        $workerStrNames[$i] = "'" . array_keys($isProcessingWorker)[$i] . "'";
      }
      $workerStrNames = implode($workerStrNames, ',');

      $wheresStr = "AND (sw.stop_worker IN ({$workerStrNames}) "; // 起動しているワーカー
      $wheresStr .= "OR  sw.id != (SELECT tmp.id FROM (SELECT MAX(id) as id FROM tb_stop_worker WHERE stop_worker = :queue_name) as tmp))"; // それぞれのワーカーの最終行以外
    }else{
      // ワーカーがすべて停止していればそれぞれのワーカーの最終行以外を無効化
      $wheresStr = "AND sw.id != (SELECT tmp.id FROM (SELECT MAX(id) as id FROM tb_stop_worker WHERE stop_worker = :queue_name) as tmp)";
    }

    /** @var \Doctrine\DBAL\Connection $dbMain */
    $dbMain = $this->getConnection('main');
    foreach ($queueNames as $queueName) {
      if(array_key_exists($queueName,$isProcessingWorker)){
        // 起動していてもジョブ実行中ならば無効にしない
        if($isProcessingWorker[$queueName] != null ){
          continue;
        }
      }

      $sql = <<<EOD
      UPDATE  tb_stop_worker sw
        SET   sw.is_active = -1
        WHERE sw.is_active != -1 
          AND sw.stop_worker = :queue_name
          {$wheresStr}
EOD;
      $stmt = $dbMain->prepare($sql);
      $stmt->bindValue(':queue_name',$queueName,\PDO::PARAM_STR);
      $stmt->execute();
    }
  }

  /**
   * 停止ワーカーの起動時間に達しているか確認し達していれば起動させる
   * @param $rootDir
   * @param $env
   * @param $isProcessingWorker
   * @return array
   * @throws \Doctrine\DBAL\DBALException
   */
  public function checkWorkerRemainingTime($rootDir,$env,$isProcessingWorker){

    $result = [
      'output' => null,
      'error'  => null
    ];

    /** @var BatchLogger $logger */
    $logger = $this->getLogger();
    /** @var \Doctrine\DBAL\Connection $dbMain */
    $dbMain = $this->getConnection('main');
    $sql = <<<EOD
    SELECT
     id
      , stop_worker
      , TIMEDIFF(sw.created_at + INTERVAL sw.stop_time MINUTE,now()) as remaining_time  /* (登録した時間 + 止める時間) - 現在の時間 = 残り時間 */
      FROM  tb_stop_worker sw
      WHERE is_active != -1
EOD;
    $stmt = $dbMain->prepare($sql);
    $stmt->execute();
    $workers = $stmt->fetchAll(\PDO::FETCH_ASSOC);

    foreach ($workers as $key => $worker){
      $remainingTime = explode(':',$worker['remaining_time']);
      $remainingSecondTime = strpos($remainingTime[0],'-') === false ? $remainingTime[0] * 60 * 60 + $remainingTime[1] * 60 + $remainingTime[2] : -1 * (abs($remainingTime[0]) * 60 * 60 + $remainingTime[1] * 60 + $remainingTime[2]);

      if($remainingSecondTime > 0){
        continue;
      }

      if(array_key_exists($worker["stop_worker"],$isProcessingWorker)){
        if($isProcessingWorker[$worker["stop_worker"]] != null){
          // 停止予定中に停止時間を超えた場合、現在処理しているジョブが終了するまで起動コマンドをスキップする(戻り値としては不必要なため消す)
          unset($workers[$key]);
          $workers = array_values($workers);
          continue;
        }
      }

      try{
        $sql = <<<EOD
          UPDATE tb_stop_worker
            SET    is_active = -1
            WHERE  id = :id
EOD;
        $stmt = $dbMain->prepare($sql);
        $stmt->bindValue(':id', $worker['id'], \PDO::PARAM_INT);
        $stmt->execute();

        // ワーカーの多重起動対策
        if($stmt->rowCount() > 0){
          $status = $this->startWorker($rootDir,$worker['stop_worker'],$env);
          if($status['error']){
            // ロールバック
            $sql = <<<EOD
              UPDATE tb_stop_worker
                SET    is_active = 0
                WHERE  id = :id
EOD;
            $stmt = $dbMain->prepare($sql);
            $stmt->bindValue(':id', $worker['id'], \PDO::PARAM_INT);
            $stmt->execute();

            throw new RuntimeException($status['error']);
          }
        }

      }catch (\Exception $e){
        $result['error'] = $e->getMessage();
      }
    }

    $result['output'] = $workers;
    return $result;
  }


  /**
   * ワーカー起動
   * @param $rootDir
   * @param $worker
   * @param $env
   * @return array
   */
  public function startWorker($rootDir,$worker,$env){
    $result = [
      'error'  => null
    ];

    /** @var BatchLogger $logger */
    $logger = $this->getLogger();

    try{
      $command = sprintf('/usr/bin/php %s/app/console bcc:resque:worker-start %s -e %s', dirname($rootDir), $worker,$env);

      $logger->info($command);
      $logger->info($env);
      $pp = popen($command, 'w');
      if (!is_resource($pp)) {
        throw new RuntimeException('ワーカーの起動に失敗しました。');
      }
      pclose($pp);
      $logger->info('ワーカーの起動に成功しました。');
    }catch (\Exception $e){
      $result['error'] = $e->getMessage();
    }
    return $result;
  }
}
